# 一、系统结构设计

* ## 1.1 体系结构

  本项目采用前后端分离的架构进行开发，前端通过向后端API发送请求获得服务，后端通过前端请求的内容来和数据库进行交互，获得数据并处理后将数据返回给前端，前端进而将其呈现给用户。整体的技术框架如下图所示：

  ![技术框架](https://alist.sanyue.site/d/imgbed/202312191747134.png)

  ### 1.1.1 前端体系结构

  #### 1.1.1.1前端技术框架

  前端我们选择使用几乎目前最新的`Vue3+Vite+TS`的技术链实现，同时在服务器端部署采用的是`nginx+uwsgi`的组合。

  相比于vue2，vue3的优势在于：

  > 1. **性能提升：** Vue 3 在性能方面有显著的提升，主要是通过对响应式系统的重写和优化实现的。新的响应式系统能够更高效地追踪数据变化，提高了渲染性能。
  > 2. **Composition API：** Vue 3 引入了 Composition API，使得组件的逻辑可以更灵活地组织和重用。这使得代码更加可维护，尤其对于大型应用而言，可以更容易地管理组件逻辑。
  > 3. **Teleport：** Vue 3 提供了 Teleport 功能，允许在组件的模板中将内容渲染到 DOM 中的任意位置。这在处理模态框、弹出菜单等情况时非常有用。

  相比于传统前端开发使用的`WebPack`开发服务器，`Vite`的优势在于：

  > 1. **快速的开发服务器：** Vite 使用原生 ES 模块的导入方式，利用现代浏览器对 ES 模块的支持，能够提供快速的开发服务器启动时间。这比传统的基于 webpack 的开发服务器更加迅速。
  > 2. **按需编译：** Vite 支持按需编译，只编译和构建你正在开发的模块，而不是整个应用。这降低了开发过程中的等待时间，提高了开发效率。
  > 3. **开箱即用的插件：** Vite 内置了对常用工具和框架的支持，如 Vue、React、TypeScript 等，使得配置变得简单，不需要复杂的配置即可开始开发。
  > 4. **ES Module Imports：** Vite 利用原生的 ES 模块导入方式，支持按需加载和 Tree-shaking，这有助于减小生成的代码体积。
  > 5. **支持 HMR（热模块替换）：** Vite 支持热模块替换，可以在不刷新整个页面的情况下替换、添加或删除模块，提供更快的开发体验。

  而nginx作为目前主流的高性能的开源反向代理服务器和 Web 服务器，其高性能和低内存消耗等优势更是不言而喻。

  整体的前端架构（包括前后端交互）如下：

  ![前端架构](https://alist.sanyue.site/d/imgbed/202312141837446.png)

  #### 1.1.1.2前端项目结构（简略版）

  ```
  |-- BUAA Hospital
      |-- .babelrc
      |-- .env
      |-- .env.development
      |-- .env.github
      |-- .gitignore
      |-- .prettierrc.json
      |-- components.d.ts
      |-- dist.zip
      |-- index.html
      |-- jsconfig.json
      |-- LICENSE
      |-- package-lock.json
      |-- package.json
      |-- postcss.config.cjs
      |-- README-en_US.md
      |-- README.md
      |-- tailwind.config.cjs
      |-- tsconfig.json
      |-- tsconfig.node.json
      |-- vite.config.ts
      |-- gulpfile.babel.js
      |   |-- index.js
      |   |-- transform.js
      |   |-- vueTemplateTsc.js
      |-- public
      |   |-- buaalogo.svg
      |   |-- grid.svg
      |   |-- vite.svg
      |-- src
          |-- App.vue
          |-- global.d.ts
          |-- main.ts
          |-- vite-env.d.ts
          |-- assets
          |-- components
          |-- pages
          |   |-- Exp403.vue
          |   |-- Exp404.vue
          |   |-- index.ts
          |   |-- payPage.vue
          |   |-- Test.vue
          |   |-- assayItem
          |   |-- assayList
          |   |-- billing
          |   |-- departmentSelect
          |   |-- diagnosisItem
          |   |-- diagnosisList
          |   |-- doctor
          |   |   |-- analysisList
          |   |   |-- checkResult
          |   |   |-- medicineList
          |   |   |-- scheduleTable
          |   |-- doctorSelect
          |   |-- home
          |   |-- login
          |   |-- manager
          |   |   |-- addDoctor
          |   |   |-- addPatient
          |   |   |-- allDoctor
          |   |   |-- allPatient
          |   |   |-- getSchedule
          |   |   |-- searchMedicine
          |   |-- payList
          |   |-- personal
          |   |-- signin
          |   |-- system
          |   |-- table
          |   |-- theme
          |   |-- user
          |   |-- welcomePage
          |-- plugins
          |-- router
          |   |-- dynamicRoutes.ts
          |   |-- guards.ts
          |   |-- index.ts
          |   |-- interface.d.ts
          |   |-- routes.ts
          |-- store
          |   |-- account.ts
          |   |-- http.ts
          |   |-- index.ts
          |   |-- loading.ts
          |   |-- menu.ts
          |   |-- setting.ts
          |-- theme
          |-- types
          |-- utils
  ```

  ### 1.1.2 后端体系结构

  在数据库的搭建上，我使用了`sql`语句进行初始化，并插入了主要的关键数据。

  后端使用了`django`框架，接收来自前端的`http`请求，与云数据库`Guass DB`进行交互，将整理好的数据传回前端或保留在后端。

  Django作为一个后端框架，主要提供以下主要功能：

  1. **ORM（对象关系映射）：** Django提供了强大的ORM系统，允许开发者使用Python代码而不是SQL语句来定义和操作数据库模型。这简化了数据库操作，提高了代码的可读性和可维护性。
  2. **视图和模板系统：** Django采用MVC（Model-View-Controller）设计模式，其中视图（View）负责处理请求并返回响应，模板（Template）用于定义HTML页面的结构。这使得开发者能够更好地组织和分离业务逻辑、表现逻辑和数据模型。
  3. **路由系统：** Django的URL映射系统允许开发者将不同的URL请求路由到相应的视图函数，从而实现对不同功能的有效分发。这种映射是在项目的`urls.py`文件中定义的。

  #### 1.1.2.1 后端环境

  具体所需依赖见下

  ```
  aiohttp==3.9.1
  aiosignal==1.3.1
  annotated-types==0.6.0
  anyio==3.7.1
  asgiref==3.7.2
  async-timeout==4.0.3
  attrs==23.1.0
  certifi==2023.11.17
  charset-normalizer==3.3.2
  colorama==0.4.6
  distro==1.8.0
  Django==4.2.6
  django-cors-headers==4.3.1
  djangorestframework==3.14.0
  exceptiongroup==1.2.0
  frozenlist==1.4.0
  h11==0.14.0
  httpcore==1.0.2
  httpx==0.25.1
  idna==3.4
  multidict==6.0.4
  mysqlclient==2.2.0
  numpy==1.26.1
  openai==0.28.0
  pydantic==2.5.1
  pydantic_core==2.14.3
  PyJWT==2.8.0
  PyMySQL==1.1.0
  pytz==2023.3.post1
  requests==2.31.0
  sniffio==1.3.0
  sqlparse==0.4.4
  tqdm==4.66.1
  typing_extensions==4.8.0
  tzdata==2023.3
  urllib3==2.1.0
  yarl==1.9.3
  ```

  #### 1.1.2.2 后端框架

  ```
  .
  ├── __init__.py
  ├── avatar.jpg
  ├── avatar_admin.jpg
  ├── db.sqlite3
  ├── manage.py
  ├── migrations
  │   ├── __init__.py
  │   ├── asgi.py
  │   ├── gptAnswer.py
  │   ├── info.json
  │   ├── initialDB.py
  │   ├── models.py
  │   ├── mysql.py
  │   ├── settings.py
  │   ├── testviews.py
  │   ├── upload.py
  │   ├── urls.py
  │   ├── views.py
  │   └── wsgi.py
  └── test.py
  ```

  具体框架如上所示。

  * `views.py`：存放主要方法
  * `mysql.py`：存放数据操作方法
  * `urls.py`：存放路由地址
  * `testviews.py`：存放测试方法
  * `models.py`：存放由数据库映射的`ORM`
  * `database.sql`：存放初始化数据的`sql`语句。
  * `manage.py`：`django`中的命令行工具
  * `gptAnswer.py`：存放调用`chatgpt`接口

## 1.2 功能结构

本次作业的内容是一个支持多种用户的北航校医院应用系统，其中涉及的实体有：病人，医生，管理员，化验订单，药品订单，诊断订单，挂号订单，诊室，部门，药品等

* 病人模块
  1. 查看自身订单
  2. 支付订单
  3. 查看诊断结果
  4. 查看化验单结果
  5. 根据医院排班自动挂号预约
  6. 智能导医台
* 医生模块
  1. 开药
  2. 下诊断书
  3. 提供化验单
  4. 查看自身排班
* 管理员模块
  1. 增加医生
  2. 增加社区病人
  3. 增加新药品
  4. 删除药品
  5. 查看病人信息，查看病人流水情况
  6. 查看医生信息

# 二、数据库基本表定义

数据库包含7个实体，14张表，使用`sql`语句进行数据库初始化，并将数据库迁移到`django.models`中，每个表对应一个模型类，类中的属性对应对应表中的列。

具体定义以及实现代码见下：

## 用户部分

由于我们的题目中存在多种用户，因此我采用了父类-子类的架构，由`User`表作为父类，`Doctor`和`Patient`作为子类，通过`User.type`进行判断，而管理员表中并无多余信息，因此我并没有针对管理员建表。

特别的是，对于我们的头像，我们使用了我们组员自己搭建的图床[www.imgbed.sanyue.site](https://imgbed.sanyue.site/)，在他的帮助下，我们可以将图片在线上传到图床中，减少数据库的冗余。

表的属性见下。

### 2.0 User(用户表)

| 属性     | 中文   | 类型         | 备注           |
| -------- | ------ | ------------ | -------------- |
| id       | 编号   | VARCHAR(25)  | NOT NULL，主码 |
| username | 用户名 | VarCHAR(25)  | NOT NULL       |
| password | 密码   | VarCHAR(25)  | NOT NULL       |
| type     | 类型   | VarCHAR(25)  | NOT NULL       |
| avatar   | 头像   | VARCHAR(150) | NOT NULL       |

```python
class User(models.Model):
    id = models.CharField(primary_key=True, max_length=25)
    username = models.CharField(db_column='USERNAME', max_length=25)  # Field name made lowercase.
    password = models.CharField(max_length=25)
    type = models.CharField(max_length=25)
    avatar = models.CharField(db_column='AVATAR', max_length=150, blank=True, null=True)  # Field name made lowercase.

    class Meta:
        managed = False
        db_table = 'user'
```

### 2.1 Patient(病人表)继承User

| 属性     | 中文           | 类型        | 备注           |
| -------- | -------------- | ----------- | -------------- |
| id       | 用户名         | VARCHAR(25) | NOT NULL，外码 |
| isComMem | 是否为社区成员 | BOOLEAN     | NOT NULL       |
| active   | 是否被删除     | BOOLEAN     | NOT NULL       |
| idCard   | 身份证号       | VarCHAR(25) |                |

```py
class Patient(models.Model):
    id = models.CharField(primary_key=True, max_length=25)
    iscommem = models.IntegerField(db_column='isComMem')  # Field name made lowercase.
    idcard = models.CharField(db_column='idCard', max_length=25, blank=True, null=True)  # Field name made lowercase.
    active = models.IntegerField()

    class Meta:
        managed = False
        db_table = 'patient'
```



### 2.2 Doctor(医生表)继承User

| 属性     | 中文         | 类型        | 备注                   |
| -------- | ------------ | ----------- | ---------------------- |
| id       | 医生编号     | VARCHAR(25) | NOT NULL，外码继承User |
| active   | 是否活跃     | BOOLEAN     | NOT NULL               |
| Tid      | 负责科室编号 | VarCHAR(25) | NOT NULL               |
| jobtitle | 职称         | VARCHAR(25) | NOT NULL               |

```py
class Doctor(models.Model):
    id = models.CharField(primary_key=True, max_length=25)
    tid = models.ForeignKey('Titles', models.DO_NOTHING, db_column='Tid')  # Field name made lowercase.
    jobtitle = models.CharField(db_column='JobTitle', max_length=25)  # Field name made lowercase.
    active = models.IntegerField()

    class Meta:
        managed = False
        db_table = 'doctor'
```

## 医院实体

医院实体主要包括了科室，药品，诊室和检查项目四种不同的实体。基本实现见下

### 2.3 Title(科室表)

| 属性 | 中文 | 类型        | 备注          |
| ---- | ---- | ----------- | ------------- |
| id   | 编号 | VARCHAR(25) | NOT NULL,主码 |
| name | 名称 | VARCHAR(25) | NOT NULL      |

```python
class Titles(models.Model):
    id = models.CharField(primary_key=True, max_length=25)
    name = models.CharField(max_length=25)

    class Meta:
        managed = False
        db_table = 'titles'
```



### 2.4 Drug(药品表)

| 属性        | 中文       | 类型        | 备注           |
| ----------- | ---------- | ----------- | -------------- |
| id          | 药品编号   | VARCHAR(25) | NOT NULL，主码 |
| isBanned    | 是否被禁止 | BOOLEAN     | NOT NULL       |
| price       | 药品价格   | FLOAT       | NOT NULL       |
| Storage     | 存储量     | FLOAT       | NOT NULL       |
| description | 药品描述   | TEXT        | NOT NULL       |

```python
class Drug(models.Model):
    id = models.CharField(primary_key=True, max_length=25)
    name = models.CharField(max_length=25)
    price = models.FloatField()
    description = models.TextField(db_column='Description')  # Field name made lowercase.
    isbanned = models.IntegerField(db_column='isBanned')  # Field name made lowercase.
    storage = models.FloatField(db_column='Storage')  # Field name made lowercase.

    class Meta:
        managed = False
        db_table = 'drug'
```

### 2.5 ROOM(诊室表)

| 属性       | 中文       | 类型        | 备注           |
| ---------- | ---------- | ----------- | -------------- |
| id         | 诊室编号   | VARCHAR(25) | NOT NULL，主码 |
| isOccupied | 是否被占用 | BOOLEAN     | NOT NULL       |
| QueueLen   | 排队人数   | int         | NOT NULL       |

```python
class Room(models.Model):
    id = models.CharField(primary_key=True, max_length=25)
    isoccupied = models.IntegerField(db_column='isOccupied')  # Field name made lowercase.
    queuelen = models.IntegerField(db_column='QueueLen')  # Field name made lowercase.

    class Meta:
        managed = False
        db_table = 'room'
```



### 2.6 checkItems(检查项目)

| 属性        | 中文         | 类型         | 备注           |
| ----------- | ------------ | ------------ | -------------- |
| id          | 检查项目编号 | VARCHAR(25)  | NOT NULL，主码 |
| price       | 检查项目价格 | FLOAT        | NOT NULL       |
| description | 检擦项目描述 | VARCHAR(255) | NOT NULL       |
| MinResult   | 最小值       | FLOAT        | NOT NULL       |
| MaxResult   | 最大值       | FLOAT        | NOT NULL       |

```python
class Checkitems(models.Model):
    id = models.CharField(primary_key=True, max_length=25)
    price = models.FloatField()
    description = models.CharField(max_length=255)
    minresult = models.FloatField(db_column='MinResult')  # Field name made lowercase.
    maxresult = models.FloatField(db_column='MaxResult')  # Field name made lowercase.

    class Meta:
        managed = False
        db_table = 'checkitems'
```

## 关系表

关系表主要分为以下几类：

1. 付费订单

   包括了

   1. 挂号
   2. 开药
   3. 化验

2. 免费订单，目前只支持诊断结果

3. 排班关系，展示医生排班情况。

对于付费订单类，我们使用了`Counter`作为基本表，以其为基础，用`RegistRelation`,`MedicinePurchase`,`LaboratoryShee`三个表来对其进行继承，使用了`Counter.id`作为外码，保持父子表的关系。

### 2.7 Counter(订单表)

| 属性   | 中文       | 类型        | 备注                      |
| ------ | ---------- | ----------- | ------------------------- |
| id     | 订单编号   | VARCHAR(25) | NOT NULL, 主码            |
| isPaid | 是否已支付 | BOOLEAN     | NOT NULL                  |
| price  | 价格       | FLOAT       | NOT NULL                  |
| Pid    | 病人编号   | VARCHAR(25) | NOT NULL，外码继承Patient |
| Did    | 医生编号   | VARCHAR(25) | NOT NULL,外码继承DOCTOR   |
| DATE   | 日期       | DATE        | NOT NULL                  |
| type   | 订单种类   | VARCHAR(25) | NOT NULL                  |

```python
class Counter(models.Model):
    id = models.CharField(primary_key=True, max_length=25)
    pid = models.ForeignKey('Patient', models.DO_NOTHING, db_column='Pid')  # Field name made lowercase.
    did = models.ForeignKey('Doctor', models.DO_NOTHING, db_column='Did')  # Field name made lowercase.
    ispaid = models.IntegerField(db_column='isPaid')  # Field name made lowercase.
    price = models.FloatField(blank=True, null=True)
    date = models.DateField(db_column='DATE')  # Field name made lowercase.
    type = models.CharField(max_length=25)

    class Meta:
        managed = False
        db_table = 'counter'
```



### 2.8 RegistRelation(登记表(挂号)

| 属性       | 中文       | 类型        | 备注                                   |
| ---------- | ---------- | ----------- | -------------------------------------- |
| id         | 订单编号   | VARCHAR(25) | NOT NULL, PRIMARY KEY，外码继承Counter |
| ROOMID     | 诊室编号   | VARCHAR(25) | NOT NULL                               |
| isFinished | 是否被完成 | BOOLEAN     | NOT NULL                               |

```python
class Registrelation(models.Model):
    id = models.OneToOneField(Counter, models.DO_NOTHING, db_column='id', primary_key=True)
    roomid = models.CharField(db_column='ROOMID', max_length=25)  # Field name made lowercase.
    isfinished = models.IntegerField(db_column='isFinished')  # Field name made lowercase.

    class Meta:
        managed = False
        db_table = 'registrelation'
```



### 2.10 MedicinePurchase

| 属性   | 中文     | 类型        | 备注                   |
| ------ | -------- | ----------- | ---------------------- |
| id     | 订单编号 | VARCHAR(25) | NOT NULL,主码          |
| drugid | 药品编码 | VARCHAR(25) | NOT NULL，外码继承Drug |
| amount | 购买数量 | FLOAT       | NOT NULL               |

```python
class Medicinepurchase(models.Model):
    id = models.OneToOneField(Counter, models.DO_NOTHING, db_column='id', primary_key=True)  # The composite primary key (id, drugId) found, that is not supported. The first column is selected.
    drugid = models.ForeignKey(Drug, models.DO_NOTHING, db_column='drugId')  # Field name made lowercase.
    amount = models.FloatField()

    class Meta:
        managed = False
        db_table = 'medicinepurchase'
        unique_together = (('id', 'drugid'),)
```



### 2.11 LaboratorySheet(化验订单)

| 属性       | 中文         | 类型         | 备注           |
| ---------- | ------------ | ------------ | -------------- |
| id         | 订单编号     | VARCHAR(25)  | NOT NULL, 主码 |
| checkName  | 化验名称     | VARCHAR(25)  | NOT NULL       |
| beginTime  | 检查时间     | DATETIME     | NOT NULL       |
| OutputTime | 结果时间     | DATETIME     | NOT NULL       |
| itemId     | 检查项目编号 | VARCHAR(25)  | NOT NULL,主码  |
| result     | 检查结果     | VARCHAR(255) | NOT NULL       |

```python
class Laboratorysheet(models.Model):
    id = models.OneToOneField(Counter, models.DO_NOTHING, db_column='id', primary_key=True)  # The composite primary key (id, itemID) found, that is not supported. The first column is selected.
    checkname = models.CharField(db_column='checkName', max_length=255)  # Field name made lowercase.
    begintime = models.DateTimeField(db_column='beginTime')  # Field name made lowercase.
    outputtime = models.DateTimeField(db_column='OutputTime', blank=True, null=True)  # Field name made lowercase.
    itemid = models.ForeignKey(Checkitems, models.DO_NOTHING, db_column='itemID')  # Field name made lowercase.
    result = models.FloatField()

    class Meta:
        managed = False
        db_table = 'laboratorysheet'
        unique_together = (('id', 'itemid'),)
```

### 2.12 Dispatcher(医生排班调度器)

| 属性       | 中文                     | 类型        | 备注           |
| ---------- | ------------------------ | ----------- | -------------- |
| TimePeriod | 时间段                   | VARCHAR(25) | NOT NULL，主码 |
| ROOMID     | 诊室编号                 | VARCHAR(25) | NOT NULL，主码 |
| doctorId   | 医生编号                 | VARCHAR(25) |                |
| TitleId    | 负责的科室或活动名称编号 | VARCHAR(25) |                |
| DATE       | 日期（星期几）           | VARCHAR(15) | NOT NULL       |

```python
class Dispatcher(models.Model):
    timeperiod = models.CharField(db_column='TimePeriod', primary_key=True, max_length=25)  # Field name made lowercase. The composite primary key (TimePeriod, ROOMID, DATE) found, that is not supported. The first column is selected.
    roomid = models.ForeignKey('Room', models.DO_NOTHING, db_column='ROOMID')  # Field name made lowercase.
    doctorid = models.ForeignKey('Doctor', models.DO_NOTHING, db_column='doctorId', blank=True, null=True)  # Field name made lowercase.
    titleid = models.CharField(db_column='TitleId', max_length=25, blank=True, null=True)  # Field name made lowercase.
    date = models.CharField(db_column='DATE', max_length=15)  # Field name made lowercase.

    class Meta:
        managed = False
        db_table = 'dispatcher'
        unique_together = (('timeperiod', 'roomid', 'date'),)
```



### 2.13 diagnosis(诊断订单)

| 属性      | 中文     | 类型        | 备注          |
| --------- | -------- | ----------- | ------------- |
| id        | 订单编号 | VARCHAR(25) | NOT NULL,主码 |
| patientId | 病人编号 | VARCHAR(25) | NOT NULL      |
| doctorId  | 医生编号 | VARCHAR(25) | NOT NULL      |
| diagnosis | 诊断说明 | TEXT        | NOT NULL      |
| time      | 诊断时间 | DATETIME    | NOT NULL      |

```python
class Diagnosis(models.Model):
    id = models.CharField(primary_key=True, max_length=25)
    patientid = models.ForeignKey('Patient', models.DO_NOTHING, db_column='patientId')  # Field name made lowercase.
    doctorid = models.ForeignKey('Doctor', models.DO_NOTHING, db_column='doctorId')  # Field name made lowercase.
    diagnosis = models.TextField()
    time = models.DateTimeField()

    class Meta:
        managed = False
        db_table = 'diagnosis'
```



## 特殊实体表

对于检查项目，我们为了方便检查创建了常用检查组合表，方便医生直接进行检查。

### 2.14 CheckCombine(常用检查组合)

| 属性        | 中文       | 属性         | 备注                               |
| ----------- | ---------- | ------------ | ---------------------------------- |
| id          | 编号       | VARCHAR(25)  | NOT NULL,主码                      |
| itemId      | 检查项编号 | VARCHAR(25)  | NOT NULL，主码，外码继承checkItems |
| description | 名称       | VARCHAR(255) | NOT NULL                           |

```python
class Checkcombine(models.Model):
    id = models.CharField(primary_key=True, max_length=25)  # The composite primary key (id, itemId) found, that is not supported. The first column is selected.
    itemid = models.ForeignKey('Checkitems', models.DO_NOTHING, db_column='itemId')  # Field name made lowercase.
    checkname = models.CharField(db_column='checkName', max_length=255)  # Field name made lowercase.

    class Meta:
        managed = False
        db_table = 'checkcombine'
        unique_together = (('id', 'itemid'),)
```

# 三、系统重要实现方法

## （token机制）（待定）

## 触发器实现与设计说明

本系统中的触发器主要涉及在删除过程中，在删除的过程中连带将其作为外码的元组一并删除

### 删除药品

```sql
CREATE TRIGGER `DELETE_DRUG` BEFORE DELETE ON `drug` FOR EACH ROW
BEGIN
    DELETE FROM `checkcombine` WHERE `id` = OLD.id;
END

CREATE TRIGGER `DELETE_DRUG` BEFORE DELETE ON `drug` FOR EACH ROW
BEGIN
    DELETE FROM `medicinepurchase` WHERE `drugId` = OLD.id;
END
```

### 删除用户

```sql
CREATE TRIGGER `DELETE_PATIENT` BEFORE DELETE ON `patient` FOR EACH ROW
BEGIN
    IF `patient`.`isComMem` = 1 THEN
        DELETE FROM `counter` WHERE `Pid` = OLD.id;
    END IF;
END
```

### 删除订单

```sql
CREATE TRIGGER `DELETE_COUNTER` BEFORE DELETE ON `counter` FOR EACH ROW
BEGIN
    DELETE FROM `registrelation` WHERE `id` = OLD.id;
    DELETE FROM `laboratorysheet` WHERE `id` = OLD.id;
    DELETE FROM `medicinepurchase` WHERE `id` = OLD.id;
END
```

## 存储过程设计与设计说明

### 通用部分

#### 登录

请求路径：`api/login/`

方法类型：`post`

输入数据：

```json
{
    username : str,
    password : str
}
```

输出数据：

```json
{
    code: number, 
    message: string, 
    type: string,
    data: 
    {
        token: string, 
        expires: float
    }
}
```

代码：

```python
def LogIn(request):
    if request.method == 'POST':
        username = request.POST.get('username',None)
        password = request.POST.get('password', None)

        db = MySQLdb.MyDatabase()
        success, code, user = db.Login(username=username, password=password)

        if user != None:
            exp = datetime.datetime.utcnow() + datetime.timedelta(days=1)
            timestamp_seconds = int(exp.timestamp())
            timestamp_milliseconds = timestamp_seconds * 1000
            payload = {
                'username': username,
                'role' : user.type,
                'exp': timestamp_milliseconds,
            }
            token = jwt.encode(payload, 'secret key', algorithm='HS256')
            request.session['username'] = username
            request.session['id'] = user.id
            request.session['type'] = user.type
            request.session.save()
            print(request.session['username'], request.session['id'], request.session['type'])
            return JsonResponse({'code': 0, 'message': 'success', 'type': user.type,
                                 'data': {'token': token, 'expires': timestamp_milliseconds}})
        else:
            return JsonResponse({
                'success': success,
                'code': code,
            })
    else:
        return HttpResponse("Not a POST request")
```

#### 注册

请求路径：`api/signUp/`

方法类型：`POST`

输入数据：

```json
{
    username : string,
    password : string,
    idcard : string
}
```

输出数据：

```json
{
    code: string
}
```

代码：

```python
def SignUpByPatient(request):
    if (request.method == 'POST'):
        try:
            data = json.loads(request.body)
            username = data.get('username', '')
            password = data.get('password', '')
            print(username, password)
            idcard = data.get('idcard', '')
            db = MySQLdb.MyDatabase()
            success, status = db.SignUpByPatient(name=username, password=password, iscommem=False, idcard=idcard)
            print(success, status)
            return JsonResponse({'code': status})
        except ValueError as e:
            return JsonResponse({'success': False, 'error': 'Invalid JSON data'})
    else:
        return HttpResponse("Not a POST request")
```



#### 登录信息

作用说明：用于前端实时得到用户信息

请求路径：`api/account/`

方法类型：`GET`

输入数据：无

输出数据：

```json
{
    account : {
        username : string,
        gender : number,
        age: number,
        avatar : string,
        jobtitle : string
    }, 
    permission : string, 
    role : string
}
```

代码

```python
def account(request):
    # 获取 session 中的信息

    # 打印 session 的键值对信息
    username = request.GET.get('username', None)
    db = MySQLdb.MyDatabase()
    account = {}
    account['username'] = username
    account['gender'] = 0
    account['age'] = 18
    permissions = []
    u = db.getUserById(db.getIdByUsername(name=username))
    permissions.append(u.type)
    try:
        account['avatar'] = u.avatar
    except:
        account['avatar'] = DEFAULT_AVATAR
    if u.type == 'doctor':
        account['jobtitle'] = db.getDoctorById(id=u.id)['jobtitle']
    else:
        account['jobtitle'] = ''
    db.updateAvatar(id=u.id, avatar=account['avatar'])
    role = u.type
    j = {'account' : account, 'permission' : permissions, 'role' : role}
    return JsonResponse(j)
```

### 病人部分

#### 智能导医台

方法说明：调用后端`chatgpt-api`接口得到医疗简易

请求路径：`api/getSuggestion/`

输入数据：

```json
{
    question : string
}
```

输出数据：

```json
{
    answer : string
}
```

代码：

```python
def answer(request):
    d = MySQLdb.MyDatabase()
    data = json.loads(request.body)
    content = data['question']
    departmentlist = d.GetDepartmentList()
    sendText = "你好，我是一名病人，我的症状是" + content + "，请我应该选择从" + str(departmentlist) + "中的哪个科室就诊？在三十到八十个字以内解决，假设你是医院的智能导医台（但回答中不要提及这一点）"
    openai.api_key = GPT_API_KEY
    openai.api_base = "https://api.openai.com/v1"
    
    print(sendText)

    response = openai.ChatCompletion.create(
        model="gpt-3.5-turbo",
        messages=[
            {'role': 'user', 'content': sendText}
        ],
        temperature=0.5,
        max_tokens=300,
        stream=True
    )

    result = ""

    for chunk in response:
        if 'choices' in chunk and 'delta' in chunk['choices'][0]:
            chunk_msg = chunk['choices'][0]['delta'].get('content', '')
            result += chunk_msg  # 将输出内容附加到结果字符串上
            #print(chunk_msg, end='', flush=True)
            #time.sleep(0.05)

    print(result)

    return JsonResponse({"answer" : result})
```





#### 获取科室名称

作用说明：获取科室列表

请求路径：`api/departmentList/`

请求类型：`GET`

输入数据：无

输出数据：

```json
{
    name : [
        name : string
    ]
}
```

代码

```python
    def GetDepartmentList(request):
    # assert request.type == 'patient'
    if (request.method == 'GET'):
        db = MySQLdb.MyDatabase()
        info = db.GetDepartmentList()
        return JsonResponse({'name' : info})
    else:
        return HttpResponse("Not a GET request")
    
    def GetDepartmentList(self):
        from .models import Titles
        result = []
        l = Titles.objects.all()
        for i in l:
            result.append(i.name)
        return result
```



#### 获取科室信息

方法说明：获取科室医生的具体信息

请求路径：`api/doctorList/`

方法类型：`POST`

输入数据：

```json
{
    departmentName : string
}
```

输出数据：

```json
{
    doctorList:[
        {
            name : string,
            jobtitle : string,
            roomid : string,
            queuelen : number
        }
    ]
}
```

代码

```python
def GetInfoListByDepartment(request):
    # assert request.type == 'patient'
    if (request.method == 'POST'):
        department = request.POST.get('departmentName',None)
        db = MySQLdb.MyDatabase()
        info = db.GetInfoListByDepartment(department)
        l = []
        for i in info:
            l.append({'name': i['doctor'], 'jobtitle' : i['jobtitle'],'room': i['room'], 'queuelen': i['queueLen']})
        L = list(l)
        print(L)
        return JsonResponse({'doctorList': L})
    else:
        return HttpResponse("Not a POST request")
```

#### 病人挂号选择医生

方法说明：病人选择医生挂号

请求路径：`api/confirmDoctor/`

方法类型：`POST`

输入数据：

```json
{
    username : string,
    name : string
}
```

输出数据：

```python
{
    id : string
}
```

代码

```python
def PatientRegistration(request):
    # assert request.type == 'patient'
    if (request.method == 'POST'):
        data = json.loads(request.body)
        print(request.body)
        name = data['userName']
        db = MySQLdb.MyDatabase()
        id = db.getIdByUsername(name=name)
        doctorId = db.getIdByUsername(data['name'])
        Payid, success, status = db.PatientRegistration(patientid=id, doctorid=doctorId)
        return JsonResponse({'id' : Payid})
    else:
        return HttpResponse("Not a POST request")

        @transaction.atomic
    def PatientRegistration(self, patientid: str, doctorid: str):
        timePeriod = self.get_time_period()
        from .models import Dispatcher, Counter, Registrelation, Patient, Room
        r0 = Dispatcher.objects.filter(doctorid=doctorid, timeperiod=timePeriod, date=self.getDate()).values_list(
            'roomid', flat=True).first()
        if r0 == None:
            print('NO DOCTOR' + doctorid + 'IN ' + timePeriod)
            return '-2', False, 404
        r = Counter.objects.filter(pid=patientid, did=doctorid, type='Registration', ispaid=False)
        if r == None:
            iscommem = Patient.objects.get(id=patientid).iscommem
            price = 1 if iscommem else 10
            id = self.createNewCounter(pid=patientid, did=doctorid, type='Registration', price=price)
            room = r0
            Registrelation.objects.create(id=Counter.objects.get(id=id), isfinished=0, roomid=room)
            print(room)
            Room.objects.filter(id=room).update(queuelen=Room.objects.get(id=room).queuelen + 1)
            return id, True, 0
        else:
            print('ALREADY REGISTERED')
            return '-2', False, 404
```



#### 获取需要支付的订单

方法说明：展示病人需要获取支付的订单

请求路径：`api/counterToPay/`

方法类型：`GET`

输入数据：

```json
{
    Pid : string
}
```

输出数据：

```json
{
    info : [
        {
            id : string,
            price : float
        }
    ]
}
```

代码

```python
def showAllNeedtoPay(request):
    # assert request.type == 'patient'
    if (request.method == 'GET'):
        data = json.loads(request.body)
        db = MySQLdb.MyDatabase()
        Pid = data['Pid']
        # Pid = '6'
        ans = db.showAllNeedToPay(Pid=Pid)
        l = []
        for i in ans:
            jsonObj = {"id": i["id"], "price": i["price"]}
            l.append(jsonObj)
        return JsonResponse({'Info': l})
    else:
        return HttpResponse("Not a POST request")
    
    
    def showAllNeedToPay(self, Pid : str):
        from .models import Counter
        l = Counter.objects.filter(pid=Pid, ispaid=False).iterator()
        res = []
        for i in l:
            res.append({'id': i.id, 'type': i.type, 'price': i.price})
        return res

```



#### 获取所有订单

方法说明：略

请求路径：`api/fetchPayList/`

请求类型：`GET`

输入数据：

```json
{
    username : string
}
```

输出数据：

```json
{
    Info:[
        {
            id : string,
            status : boolean,
            type : string,
            price : float
        }
    ]
}
```

代码

```python
def showAllinCounter(request):
    # assert request.type == 'patient'
    if (request.method == 'GET'):
        db = MySQLdb.MyDatabase()
        username = request.GET.get('username', None)
        Pid = db.getIdByUsername(name=username)
        # Pid = '6'
        ans = db.showAllinCounter(Pid=Pid)
        l = []
        for i in ans:
            jsonObj = {"id": i["id"], 'status' : i['ispaid'], 'type' : i['type'], 'price' : i['price']}
            l.append(jsonObj)
        return JsonResponse({'Info': l})
        
    def showAllinCounter(self, Pid : str):
        from .models import Counter
        l = Counter.objects.filter(pid=Pid).iterator()
        res = []
        for i in l:
            res.append({'id': i.id, 'type': i.type, 'ispaid': i.ispaid, 'price': i.price})
            if i.price == None:
                print('price is None')
            else:
                print(i.price)
        return res
```

#### 对所有订单付款

方法说明：略

请求路径：`api/payAllCounter/`

方法类型：`POST`

输入数据：

```json
{
    username : string
}
```

输出数据：

```json
{
    success : string,
    code : number
}
```

代码

```python
def PayAll(request):
    # assert request.type == 'patient'
    if request.method == 'POST':
        print("-------------------------------")
        data = json.loads(request.body)
        # Pid = '6'
        db = MySQLdb.MyDatabase()
        Pid = db.getIdByUsername(name=data['userName'])
        print(Pid)
        success, status = db.PayAll(Pid=Pid)
        return JsonResponse({'success' : success, 'code' : status})
    else:
        return HttpResponse("Not a POST request")
```



#### 支付单个订单

方法说明：略

请求路径：`api/finishPay/`

方法类型：`POST`

输入数据：

```json
{
    id : string
}
```

输出数据：

```json
{
    message : string
}
```

代码

```python
def finishPay(request):
    # assert request.type == 'patient'
    if request.method == 'POST':
        data = json.loads(request.body)
        Payid = data['id']
        db = MySQLdb.MyDatabase()
        if Payid != '-1':
            r = db.finishPay(id=Payid)
            if r:
                return HttpResponse('Success')
            else:
                return HttpResponse('Failed')
        else:
            print('PayAll')
            return PayAll(request=request)
```



#### 获取诊断列表

方法说明：获取该病人的诊断列表

请求路由：`api/getDiagnosisByPid/`

方法类型：`GET`

输入数据：

```json
{
    Pid : string
}
```

输出数据：

```json
{
    Info : [
        {
            time : string,
            statement : string
        }
    ]
}
```

代码

```python
def getDiagnosisByPid(request):
    # assert request.type == 'patient'
    if request.method == 'GET':
        # Pid = request.session['id']
        # Pid = '6'
        data = json.loads(request.body)
        Pid = data['Pid']
        db = MySQLdb.MyDatabase()
        ans = db.getDiagnosisByPid(Pid=Pid)
        l = []
        for i in ans:
            jsonObj = {"time": i["time"], "statement": i["statement"]}
            l.append(jsonObj)
        return JsonResponse({'Info': l})
    else:
        return HttpResponse("Not a GET request")
```



#### 获取诊断结果

方法说明：略

请求路径：`api/getDiagnosis`

方法类型：`GET`

输入数据：

```json
{
    id : string
}
```

输出数据：

```json
{
    info : {
        doctor : string,
        statement : string,
        time : string
    }
}
```

代码

```python
    def getDiagnosisById(self, id : str):
        from .models import Diagnosis
        r = Diagnosis.objects.get(id=id)
        res = {'doctor' : self.getNameById(r.doctorid.id), 'statement' : r.diagnosis, 'time' : r.time}
        return res
    
    def getDiagnosis(request):
    db = MySQLdb.MyDatabase()
    data = json.loads(request.body)
    id = data['id']
    r = db.getDiagnosisById(id=id)
    return JsonResponse({'info' : r})
```



#### 获取化验订单列表

请求路由：`api/getLaboratorySheetids/`

请求类型：`POST`

输入数据：

```json
{
    username : string
}
```

输出数据：

```json
{
    assayList : [
        id: string,
        checkName : string,
        time : string
    ]
}
```

代码

```python
def getLaboratorySheetids(request):
    # assert request.type == 'patient'
    if request.method == 'GET':
        # Pid = request.session['id']
        # Pid = '6'
        username = request.GET.get('username', None)
        db = MySQLdb.MyDatabase()
        Pid = db.getIdByUsername(username)
        print(Pid)
        ans = db.showAllLaboratorySheetIds(Pid=Pid)
        print(ans)
        return JsonResponse({'assayList': ans})
    else:
        return HttpResponse("Not a GET request")
    
    def showAllLaboratorySheetIds(self, Pid: str):
        from .models import Laboratorysheet, Counter, Checkitems
        id = Counter.objects.filter(pid=Pid, type='Laboratory').iterator()
        res = []
        for i in id:
            print(i.id)
            if i.price == 0:
                continue
            print(i)
            l = Laboratorysheet.objects.filter(id=i)
            if len(l) != 0:
                x = l[0]
                res.append({'id': x.id.id, 'checkName' : x.checkname, 'time' : self.formatedDate(str(x.begintime))})
        return res
```



#### 获取化验结果

方法路径：`api/getLaboratorySheet/`

方法类型：`POST`

输入数据：

```json
{
    id : string
}
```

输出数据：

```json
{
    assayItemList: [
        {
            itemid : string,
            checkName : string,
            result : float,
            minresult : float,
            maxresult : float,
            outputtime : string
        }
    ]
}
```

代码

```python
    def getLaboratorySheet(self, id: str):
        print(id)
        from .models import Laboratorysheet, Counter
        l = Laboratorysheet.objects.filter(id=Counter.objects.get(id=id)).iterator()
        print(l)
        if l == None:
            return False
        else:
            res = []
            for i in l:
                print(i)
                from .models import Checkitems
                res.append({'itemid': int(i.itemid.id), 'checkName': i.itemid.description, 'result': i.result if i.result != None else -1,
                            'minresult': i.itemid.minresult,
                            'maxresult': i.itemid.maxresult, 'outputtime': str(datetime.now()) if i.outputtime == None else self.formatedDate(str(i.outputtime))
                            })
            print(res)
            return res
    
    def getLaboratorySheetids(request):
    # assert request.type == 'patient'
    if request.method == 'GET':
        # Pid = request.session['id']
        # Pid = '6'
        username = request.GET.get('username', None)
        db = MySQLdb.MyDatabase()
        Pid = db.getIdByUsername(username)
        print(Pid)
        ans = db.showAllLaboratorySheetIds(Pid=Pid)
        print(ans)
        return JsonResponse({'assayList': ans})
    else:
        return HttpResponse("Not a GET request")
```

#### 注销账户

请求路径：`api/deleteAccount/`

方法类型：`POST`

输入数据：

```json
{
    username : string
}
```

输出数据：

```json
{
    success : boolean
}
```

代码：

```python
def deletePatient(request):
    # assert request.type == 'patient'
    if request.method == 'POST':
        # Pid = request.session['id']
        data = json.loads(request.body)
        username = data['username']
        db = MySQLdb.MyDatabase()
        Pid = db.getIdByUsername(name=username)
        db.SoftDeletePatient(id=Pid)
        return JsonResponse({"success" : True})
    else:
        return HttpResponse("Not a POST request")
```





### 医生部分

#### 医生开药

请求路径：`api/sendMedicineList/`

请求类型：`POST`

输入数据：

```json
{
    username : string,
    Pid : string,
    MedicineList : [string],
    AmountList : [number]
}
```

输出数据：

```json
{
    success : string,
    code : number
}
```

代码：

```python
def PrescribeMedication(request):
    # assert request.type == 'doctor'
    if request.method == 'POST':
        # Did = request.session['id']
        data = json.loads(request.body)
        db = MySQLdb.MyDatabase()
        username = data['username']
        print(data)
        Did = db.getIdByUsername(name=username)
        # Did = '5'
        Pid = data['Pid']
        print(Pid)
        MedcineList = data['MedicineList']
        AmountList = data['AmountList']
        if MedcineList == None or AmountList == None:
            print('NOT LIST')
            return HttpResponse("NOT LIST")
        else:
            print('LIST')
            success, status = db.PrescribeMedication(did=Did, pid=Pid, nameList=MedcineList, amount=AmountList)
            return JsonResponse({'success' : success, 'code' : status})
    else:
        return HttpResponse("Not a POST request")
    
    def PrescribeMedication(self, nameList : list, amount : list, pid: str, did: str):
        idList = []
        for i in nameList:
            from .models import Drug
            result = Drug.objects.filter(name=i)
            if len(result) == 0:
                return False, 404
            idList.append(result[0].id)

        id = self.createNewCounter(pid=pid, did=did, type='Medicine', price=0)
        if id == False:
            print(pid)
            print(did)
            return False, 404
        from .models import Medicinepurchase, Counter, Drug
        for i in range(len(idList)):
            Medicinepurchase.objects.create(id=Counter.objects.get(id=id), drugid=Drug.objects.get(id=idList[i]), amount=amount[i])
            Counter.objects.filter(id=id).update(
                price=Counter.objects.get(id=id).price + int(amount[i]) * Drug.objects.get(id=idList[i]).price)
            Drug.objects.filter(id=idList[i]).update(storage=Drug.objects.get(id=idList[i]).storage - int(amount[i]))
        return True, 0
```



#### 搜索药品

支持关键词搜索药品

请求路径：`api/getMedicineList/`

输入数据

```json
{
    name : string
}
```

输出数据：

```json
{
    medicineList : [
        id : string,
        name : string,
        price : float,
        description : string
    ]
}
```

代码

```python
    def getMedicineList(self, name : str):
        from .models import Drug
        r = Drug.objects.all().iterator()
        res = []
        for i in r:
            if i.name.find(name) != -1 or i.description.find(name) != -1:
                res.append({'id': i.id, 'name': i.name, 'price': i.price, 'amount' : i.storage, 'description' : i.description})
        return res
    
    def getMedicineList(request):
    db = MySQLdb.MyDatabase()
    name = request.GET.get('name', None)
    r = db.getMedicineList(name=name)
    print(r)
    return JsonResponse({'medicineList' : r})
```

#### 获取化验项目列表

请求路径：`api/getAnalysisName/`

请求类型：`GET`

输入数据：无

输出数据：

```json
{
    info : [
        checkName : string
    ]
}
```

代码：

```python
    def getAnalysisList(self):
        from .models import Checkcombine
        self.connect()
        sql = "SELECT DISTINCT checkName FROM checkCombine;"
        self.cursor.execute(sql)
        result = self.cursor.fetchall()
        return result
```

#### 给病人选择化验项目

方法说明：为病人选择具体化验项目，支持多个化验项目同时进行

请求路径：`api/sendAnalysisList/`

输入数据：

```json
{
    username : string,
    Pid : string,
    AnalysisList : [
        checkName : string
    ]
}
```

输出数据：

```json
{
    success : string,
    code : number
}
```

代码：

```python
    def conductAlaboratoryAnalysis(self, Pid: str, Did: str, checkItemIds : list, checkName: str):
        from .models import Checkcombine
        m = Checkcombine.objects.filter(checkname=checkName)
        if m == None:
            assert len(checkItemIds) != 0
            from .models import Laboratorysheet, Counter
            id = str(int(Counter.objects.all().order_by('-id')[0].id) + 1)
            Counter.objects.create(id=id, pid=Pid, did=Did, price=0, ispaid=0, type='Laboratory', date=datetime.now())
            for i in checkItemIds:
                from .models import Checkitems
                Laboratorysheet.objects.create(id=id, itemid=i, time=datetime.now(), checkName=checkName)
                Counter.objects.filter(id=id).update(
                    price=Counter.objects.get(id=id).price + Checkitems.objects.get(itemid=i).price)
            return True, 0
        else:
            r = Checkcombine.objects.filter(checkname=checkName).iterator()
            l = Checkcombine.objects.filter(checkname=checkName)
            if len(l) == 0:
                return False, 404
            from .models import Laboratorysheet, Counter, Patient, Doctor, Checkitems
            id = self.genCounterId()
            Counter.objects.create(id=id, pid=Patient.objects.get(id=Pid), did=Doctor.objects.get(id=Did), price=0, ispaid=0, type='Laboratory', date=datetime.now())
            for i in r:
                from .models import Checkitems
                try:
                    Laboratorysheet.objects.create(id=Counter.objects.get(id=id), itemid=i.itemid, begintime=datetime.now(), checkname=checkName, result=-1)
                    Counter.objects.filter(id=id).update(price=Counter.objects.get(id=id).price + i.itemid.price)
                except:
                    print(i.itemid)
                    return False, 404
            return True, 0
        
  @transaction.atomic 
def conductLaboratorySheet(request):
    # assert request.type == 'doctor'
    if request.method == 'POST':
        # Did = request.session['id']
        # Did = '5'
        data = json.loads(request.body)
        username= data['username']
        db = MySQLdb.MyDatabase()
        Did = db.getIdByUsername(name=username)
        Pid = data['Pid']
        checkName = data['checkName']
        checkItemIds = data['checkItemIds'] if 'checkItemIds' in data else None
        success, status = db.conductAlaboratoryAnalysis(checkName=checkName, checkItemIds=checkItemIds, Did=Did, Pid=Pid)
        return JsonResponse({'success' : success, 'code' : status})
    else:
        return HttpResponse("Not a POST request")      

```

#### 对指定病人下诊断

请求路由：`api/sendCheckResult/`

方法类型：`POST`

方法说明：给定病人信息，医生为病人下诊断书

输入数据：

```json
{
    Pid : string,
    username : string,
    Diagnosis : string
}
```

输出数据

```json
{
    success : string,
    code : int
}
```

代码：

```python
@csrf_exempt
def MedicalDiagnosisStatement(request):
    # assert request.type == 'doctor'
    if request.method == 'POST':
        # Did = request.session['id']
        data = json.loads(request.body)
        # Did = '5'
        name = data['username']
        db = MySQLdb.MyDatabase()
        Did = db.getIdByUsername(name=name)
        Pid = data['Pid']
        Statement = data['Diagnosis']
        success, status = db.MedicalDiagnosisStatement(Did=Did, Pid=Pid, Statement=Statement)
        return JsonResponse({'success': success, 'code': status})
    else:
        return HttpResponse("Not a POST request")
    

    def MedicalDiagnosisStatement(self, Did: str, Pid: str, Statement: str):
        from .models import Diagnosis, Patient, Doctor
        if len(Diagnosis.objects.all()) == 0:
            id = '1'
        else:
            self.connect()
            sql = "SELECT MAX(CAST(id AS UNSIGNED)) AS max_id FROM DIAGNOSIS"
            self.cursor.execute(sql)
            id = self.cursor.fetchone()
            id = str(int(id['max_id']) + 1)
            self.close()
        Diagnosis.objects.create(id=id, doctorid=Doctor.objects.get(id=Did), patientid=Patient.objects.get(id=Pid), time=datetime.now(), diagnosis=Statement)
        return True, 0
```

#### 查看排班

请求路由：`api/sendCheckResult/`

方法说明：医生界面调用此方法查看医生的排班情况

方法类型：`POST`

输入数据：

```json
{
    username : string
}
```

输出数据：

```json
{
    info : [
        string
    ]
}
```

代码

```python
def getDispatch(request):
    db = MySQLdb.MyDatabase()
    username = request.GET.get('username', None)
    print(username)
    id = db.getIdByUsername(name=username)
    print(id)
    r = db.getDispathcOfDoc(Did=id)
    print(r)
    return JsonResponse({'info': r})

    def getDispathcOfDoc(self, Did : str):
        from .models import Dispatcher, Doctor
        Did = Doctor.objects.get(id=Did)
        r = Dispatcher.objects.filter(doctorid=Did).iterator()
        res = []
        day = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
        period = ['morning', 'afternoon']
        for i in period:
            for j in day:
                d = Dispatcher.objects.filter(doctorid=Did, date=j, timeperiod=i)
                if len(d) != 0:
                    res.append(d[0].roomid.id + '诊室😷')
                else:
                    res.append('休息💤')
        print(res)
        return res
```

### 管理员部分

#### 添加医生

方法说明：略

请求路由：`api/sendDoctorList/`

输入数据：

```json
{
    username : string
    tittle : string
    password : string
}
```

输出数据：

```json
{
    success : boolean
}
```

代码：

```python
def addDoctor(request):
    db = MySQLdb.MyDatabase()
    data = json.loads(request.body)
    name = data['username']
    tittle = data['tittle']
    password = data['password']
    l, _ = db.addDoctor(name=name, tittle=tittle, password=password)
    return JsonResponse({'success': l})

    def addDoctor(self, name: str, tittle: str, password: str):
        from .models import Doctor, User
        id = self.genUserId()
        User.objects.create(id=id, username=name, password=password, type='Doctor', avatar=DEFAULT_AVATAR)
        Doctor.objects.create(id=id, tid=self.getTidByName(name=tittle), active=1, jobtitle='主治医师')
        return True, 0
```

#### 添加社区病人

方法说明：略

请求路由：`api/addPatient/`

输入数据：

```json
{
    username : string,
    password : string
}
```

输出数据：

```json
{
    success : boolean
}
```

代码：

```python
    def addCommemPatient(self, username : str, password : str):
        from .models import User, Patient
        id = self.genUserId()
        User.objects.create(id=id, username=username, password=password, type='patient', avatar=DEFAULT_AVATAR)
        Patient.objects.create(id=id, iscommem=True, active=True)
        return True, 0
```

#### 管理药品

管理药品包括了查询药品，新增药品，删除药品

##### 查询药品

同医生部分

##### 新增药品

请求路由：`api/addMedicine/`

输入数据：

```json
{
    Medicine : string,
    Amount : FLOAT,
    Price : FLOAT,
    Description : string
}
```

输出数据：

```json
{
    success : boolean
}
```

代码：

```python
def addMedicine(request):
    data = json.loads(request.body)
    Medicine = data['Medicine']
    Amount = data['Amount']
    Price = data['Price']
    Description = data['Description']
    db = MySQLdb.MyDatabase()
    db.addMedicine(name=Medicine, amount=Amount, price=Price, description=Description)
    return JsonResponse({'success': True})

    def addMedicine(self, name : str, price : float, amount : int, description : str):
        from .models import Drug
        d = Drug.objects.get(name=name)
        if d is None:
            self.connect()
            sql = "SELECT MAX(CAST(id AS UNSIGNED)) AS max_id FROM DRUG"
            self.cursor.execute(sql)
            result = self.cursor.fetchone()
            max_id = result['max_id']
            id = str(int(max_id) + 1)
            Drug.objects.create(id=id, name=name, price=price, storage=amount, description=description, isbanned=False)
            return True, 0
        else:
            Drug.objects.filter(name=name).update(storage=Drug.objects.get(name=name).storage+float(amount))
            return True, 0
```

##### 删除药品

请求路由：`api/hardDeleteDrug/`

输入数据：

```json
{
    name : string
}
```

输出数据：

```json
{
    success : boolean
}
```

代码：

```python
def hardDeleteDrug(request):
    assert request.type == 'admin'
    if request.method == 'POST':
        name = request.get('name')
        db = MySQLdb.MyDatabase()
        db.HardDeleteDrug(name=name)
        return JsonResponse({'success': True, 'code': 0})
    else:
        return HttpResponse("Not a POST request")

    def HardDeleteDrug(self, id: str):
        from .models import Drug
        self.connect()
        sql = "DELETE FROM DRUG WHERE id = %s"
        self.cursor.execute(sql, id)
        self.connection.commit()
        return True
```



#### 查看医生

请求路由：`api/getAllDoctors/`

方法类型：`GET`

输入数据：无

输出数据：

```json
{
    doctorList : [
        {
            id : string,
            name : string,
            jobtitle : string,
            department : string
        }
    ]
}
```

代码：

```python
    def getAllDoctors(self):
        from .models import Doctor, User
        r = Doctor.objects.all().iterator()
        res = []
        for i in r:
            res.append({'id': i.id, 'name': User.objects.get(id=i.id).username, 'department': i.tid.name, 'jobtitle' : i.jobtitle})
        return res
```



#### 查看患者

请求路由：`api/getAllPatients/`

方法类型：`GET`

输入数据：无

输出数据：

```json
{
    patientList : [
        
        {
            id : string,
            name : string,
            iscommem : string,
            sum : number,
        }
    ]
}
```

代码：

```python
    def getAllPatients(self):
        from .models import Patient, User
        r = Patient.objects.filter(active=True).iterator()
        res = []
        for i in r:
            res.append({'id': i.id, 'name': User.objects.get(id=i.id).username, 'iscommem': '社区用户' if i.iscommem else '非社区用户', 'sum' : self.getCounterSumOfPatient(i.id)})
        res.sort(key=lambda x: x['sum'], reverse=True)
        return res
```



# 四、系统实现效果

## 4.1公有界面

### 4.1.1系统首页

用户进入网站后会首先进入系统的首页，首页简单介绍了系统的功能，之后用户可以点击登录按钮进入系统登录界面。

![image-20231211191940784](https://alist.sanyue.site/d/imgbed/202312111922599.png)

### 4.1.2登录界面

用户登入系统的界面，医生、病人、管理员三方使用统一登录界面，可以使用用户名/用户编号和密码进行登录，如果没有输入某一项或者用户名密码错误，该界面会给出相应提示。

![image-20231211193800701](https://alist.sanyue.site/d/imgbed/202312111938645.png)

### 4.1.3注册界面

根据设计，注册界面目前仅支持**非社区用户注册**，由于系统中之前没有过这些用户的信息，因此需要他们在设置自己的用户名和密码的同时输入自己的身份证号进行身份的认证。

![image-20231211194257039](https://alist.sanyue.site/d/imgbed/202312111942939.png)

### 4.1.4主页

所有用户（医生、病人、管理员）进入系统后都会被路由到主页，这里会有进入系统的欢迎辞，同时还设置了**智能导医台功能**，通过调用ChatGpt接口，根据用户输入的自己的病情给用户提供一些建议，包括就诊科室等内容。

![image-20231211200950318](https://alist.sanyue.site/d/imgbed/202312112010295.png)

### 4.1.5个人中心

个人中心展示了用户的用户名、角色（医生、病人、管理员）等信息，同时提供了**退出登录**和**注销账号**操作。点击退出登录后会返回到系统登录页面，点击注销账号会出现警示弹窗，如果用户确认要注销账号，则成功注销后返回到系统的登录页面。

![image-20231211205759734](https://alist.sanyue.site/d/imgbed/202312112057918.png)

（确认注销账号弹窗）

![image-20231211211120985](https://alist.sanyue.site/d/imgbed/202312112111799.png)

 ## 4.2病人界面

### 4.2.1挂号预约界面

罗列了医院所有可以挂号地科室，病人可以结合智能导医台的建议和自己的实际情况选择需要就诊的科室，进入医生选择界面。

![image-20231211201201479](https://alist.sanyue.site/d/imgbed/202312112012774.png)

### 4.2.2医生选择界面

进入医生选择界面后，病人能够看到当前该科室所有可接诊的医生的有关信息（休息的医生不会显示），包含诊室编号、排队人数（含诊室队伍拥挤情况）等，病人可以根据有关信息预约对应的医生。

![image-20231211201436751](https://alist.sanyue.site/d/imgbed/202312112014946.png)

### 4.2.3挂号缴费界面

选择好医生后，系统会自动跳转到缴费界面，非社区病人挂号费为10元，社区病人挂号费为1元，用户可以选择立即缴费或稍后缴费，选择后跳转回到医生选择界面。

![image-20231211201759551](https://alist.sanyue.site/d/imgbed/202312112017732.png)

### 4.2.4费用清单

展示病人当前所有的费用清单，包含已缴费和未缴费的账单，立即缴费功能会**计算所有未缴费账单的总额**，然后跳转到缴费界面（与挂号缴费界面类似）。

![image-20231211202356072](https://alist.sanyue.site/d/imgbed/202312112023201.png)

### 4.2.5化验结果查询

展示病人当前所有的化验结果，展示化验**结果编号、化验名称、化验时间**等信息，用户可以选择想要查询的具体化验结果，点击`查看详情`进入该项化验结果的详情页。

![image-20231211202803468](https://alist.sanyue.site/d/imgbed/202312112028672.png)

### 4.2.6化验详情查看

展示某一个化验内容的具体结果，包含**项目编号，化验项目，化验结果，最小参考值，最大参考值，化验时间**等内容。其中，每一项的化验结果会根据最小参考值和最大参考值以及实际结果判断结果是否在正常范围内，并且直观地给出`正常`或`异常`的评估。

![image-20231211203034553](https://alist.sanyue.site/d/imgbed/202312112030674.png)

### 4.2.7诊断结果清单

展示病人所有的诊断结果，包含开具该诊断结果的**医生姓名，诊断时间**，点击`查看详情`后可以跳转到具体的诊断结果页面。

![image-20231211204302419](https://alist.sanyue.site/d/imgbed/202312112043543.png)

### 4.2.8诊断详情

展示具体的诊断详情，包括**诊断结果、编号、医生姓名、诊断时间**等内容。

![image-20231211205457002](https://alist.sanyue.site/d/imgbed/202312112054208.png)

## 4.3医生界面

### 4.3.1开药界面

展示医生给当前病人开具的药品清单，包括**药品名、药品id、用量**等内容。医生可以通过搜索栏输入药品名来从后端获取药品的信息，为病人输入用量，并添加到开药清单中。选择药品与用量完成后，医生可以通过点击按钮来上传药品清单。

![image-20231214174649707](https://alist.sanyue.site/d/imgbed/202312141746005.png)

### 4.3.2检查项目界面

展示医生给当前病人开具的检查项目清单，例如血常规等化验项目。医生可以从已有项目列表中选择并添加检查项目到清单中，并点击上传。同样需要输入病人信息。

![image-20231214174751072](https://alist.sanyue.site/d/imgbed/202312141747320.png)

### 4.3.3诊断结果界面

展示医生给当前病人输入诊断结果，完成后可上传。同样需要输入病人信息。

![image-20231214174817383](https://alist.sanyue.site/d/imgbed/202312141748580.png)

### 4.3.4排班界面

展示医生一周的排班坐诊日程表，分为上午下午两个时间段。如果有安排坐诊，表格中会显示坐诊的诊室，没有则显示休息。

![image-20231214174907646](https://alist.sanyue.site/d/imgbed/202312141749878.png)

## 4.4管理员界面

### 4.4.1添加医生界面

展示管理员向数据库中添加新的医生信息，或修改已有医生的**姓名、岗位、用户密码**等信息，完成后可上传。

![image-20231214175220773](https://alist.sanyue.site/d/imgbed/202312141752920.png)

### 4.4.2添加患者界面

展示管理员向数据库中添加新的患者信息，或修改已有患者的**姓名、用户密码**等信息，完成后可上传。

![image-20231214175242863](https://alist.sanyue.site/d/imgbed/202312141752090.png)

### 4.4.3管理药品界面

展示管理员向数据库中添加新的药品信息，或修改已有药品的**药品名、价格、库存、作用描述**等信息，或**删除**已有药品。添加或修改后需手动点击上传，删除则只需点击删除。

![image-20231214175324706](https://alist.sanyue.site/d/imgbed/202312141753963.png)

### 4.4.4查看所有医生

可以查看目前所有医生的姓名、id、部门、职称等内容。

![image-20231214175703849](https://alist.sanyue.site/d/imgbed/202312141757065.png)

### 4.4.5查看所有患者

可以查看目前所有患者的姓名、id、是否为社区成员、总流水等内容。

![image-20231214175757245](https://alist.sanyue.site/d/imgbed/202312141757433.png)

# 五、感想

**@陈泓兆：**在深入研究错综复杂的数据库设计时，我认识到创建一个高效、结构合理的数据模型至关重要。设计数据库模式以捕获病人信息、药物和处方历史，需要仔细考虑表与表之间的关系，在规范化和非规范化之间取得平衡，以确保数据库能够有效地支持要求。

开发过程并非没有挑战。调试与处方数据相关的问题、优化数据库查询以实现快速检索，以及将这些功能无缝集成到 Vue 组件中，所有这些都带来了独特的障碍。克服这些挑战不仅磨练了我的技术能力，还让我对数据库技术与医疗的交集产生了更深的理解。

**@黄一轩：**在本学期学习数据库课程和进行数据库大作业的开发之前，我对数据库虽然有所使用，但是对它的了解仅仅停留在不是那么熟练的使用层次，但是经过这一学期的学习，尤其是和后端开发的同学讨论数据库结构、优化等的过程中，我对数据库的工作原理和优化方式等都有了进一步的了解和更加深刻的掌握。

当然，相比于这个，由于我负责的是前端开发工作，我认为我在前端项目的设计和实现，尤其是Vue、axios等工具的使用层面取得了长足的进步，以往虽然也有过搭建个人博客的经验，但是那时对前端的理解是局限且片面的，经过自己实现`BUAA Hospital`这个中型的系统之后，我对前端的要求、实现、前后端交互等概念的理解程度显著提高。同时通过和后端开发的同学一起进行前后端连接和调试的工作，我对`Django`框架的原理和计算机网络的相关知识了解得也更加深刻。

除此之外，在本项目中，我还负责了项目的服务器部署，图床的搭建等工作，尽管我以前也在服务器上部署过不少项目，但是大部分都是基于一些优秀的开源项目修改而来，并且有比较详细的教程介绍搭建的方式。相比之下，这次是第一次部署自己开发的项目，当然也遇到了很多以往未曾出现过的问题，中间也有过一段心力交瘁的时间，但是最后还是依靠自己的摸索和调试完成了最终的搭建工作，并且还通过套用CDN、使用多线程等技术提高了项目部署的整体质量，这些对提升我服务器管理和运维的能力都有着不小的帮助。

总而言之，这学期的数据库开发整体而言比较顺利，虽然中间有一些不甚美好的回忆，但是自始至终参与并完成这个项目，还是令我受益良多。

**@周靖宇：**在本次数据库大作业的过程中，我担任了后端兼任队长的角色，这对我来说，既是挑战也是收获。

首先是选题阶段，我在选题阶段受到病痛困扰，来回奔波于北医三院和学校之间，我发现了医院作为选题的可能性，事实上，北医三院的app对病人来说有着查看一些订单的功能，对那几周每天都去化验的我来说非常方便，但是北医三院的导医台依旧有着很大的优化空间，我以此为灵感，想出来去写一个支持医生病人和管理员三种用户的`web`应用，也算是结合了生活。

之后便是开发阶段了，我在写后端的过程中也深刻感受到了**设计大于开发**的思想，一个优雅的数据库对后端的开发毫无疑问是事半功倍，数据库的结构也直接确定了后端的开发难度，在开发的过程中，我至少两次对数据库的结构进行了大改，我不怕重构，只怕写出的代码不是我心中想要的架构，也怕写出来是屎山，处处充满了无用的冗余数据。

在开发的过程中，我使用的是`django`框架，`django`框架非常简单，学习起来基本上没什么成本，也有着`py`语言的脚本性，写起来非常方便，但是我觉得这个框架的响应速度并不是很好，在我们把后端部署到服务器之后尤其明显，听说真正的后端研发使用最多的语言还是`java`，希望之后有机会试一试。

作为队长，我觉得我做的不够好，我没有很完美的统筹团队的步伐，我和一位同学可以说高效按时的完成了我们需要的任务，但是另一位同学的效率确实不敢恭维，我作为队长没有成功带领大家同进同退，导致最后的时间特别紧，部署到服务器上已经是答辩之前的一天的事情了。

但是我认为在团队开发的过程中部分同学的积极性有很大的问题，两次答辩均未到场，每次研讨迟到半小时起步，进度极慢，导致其余同学两三周之前已经完成了自己的开发任务之后仍然是原地踏步。到最后界面的结尾仍然需要其他两位同学疲于奔命，最后一天才正式完成服务器+图床的任务，我认为可能也有我统筹不力的缘故。

总之在数据库大作业的过程中收获良多，希望之后可以继续在数据库相关的知识上有所了解，继续研究。